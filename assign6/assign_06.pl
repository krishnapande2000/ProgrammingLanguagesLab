/*******************************************************************************
 *  								Assignment -5
 *	Krishna Pande, Roll-No- 180101038
 *  To run the assignment go to path of assign_06.pl file then execute the following-
 *  Make sure this folder has the file Mazedata.pl as generated by the generateMaze 2.cpp code given in the assignment
 *  For executing the code on ubuntu 18.04
 * 	Compile and load -> swipl -s assign_06.pl
 *  this will show the testcases embedded here. 
 *  Execute different cases by runnig the following commands now
 * 	shortest_path(X,Y).
 *  for your own testcase where X and Y are integers between 1 and 99.
 *  I have not used the Result variable as it is not needed here. The shortest_path predicate
 *  itself displays the required output on the terminal window. 
 *******************************************************************************/

/*
The code implements djikstras single source shortest_path algo for the source of the query
and then reverses the path (if found) for the destination for the output 
									  path from source to destination along with its length stored as weight.
							else  returns that the path doent exist
*/

:- dynamic(reversePath/2).
:- consult('Mazedata').
 
% makes edges behave as undirected and checks if it has faulty nodes
valid_edge(X, Y, Weight) :- 
	mazelink(X,Y), 
	mazelink(Y,X), 
	not(faultynode(X)), 
	not(faultynode(Y)),
	Weight is 1.

%to add a new faulty node
addFaultyNode(X) :- 
	assert(faultynode(X)),
	format('~w is added as a faultynode\n\n', [X]).
	
%to remove a faulty node	
removeFaultyNode(X) :-
	faultynode(X) -> retract(faultynode(X)),format('~w is removed as a faultynode\n\n', [X]);
	format('~w is already not a faultynode\n\n', [X]).	
 
% if path is less than the currently stored path, replace it
shorter_path([H|Path], Weight) :-		       
	reversePath([H|_], W), !, Weight < W,          
	retract(reversePath([H|_], _)),
	assert(reversePath([H|Path], Weight)).

% store new path for each node reached
shorter_path(Path, Weight) :-		       
	assert(reversePath(Path, Weight)).
 
% traverses each unvisited adjacent node then compares weight to current minimum weight
% shortest path and weight are updated, then traverse to adjacent
djikstra(Source, Path, Weight) :-		    
	valid_edge(Source, T, W),		    
	not(memberchk(T, Path)),	    
	shorter_path([T, Source|Path], Weight + W), 
	djikstra(T, [Source|Path], Weight + W).	    
 
% removes past solutions to clear and traverses from original source
djikstra(Source) :-
	retractall(reversePath(_,_)),           
	djikstra(Source, [], 0).              
djikstra(_).
 

% finds all weights, once the destination is reached, path and distance are reported
shortest_path(Source, Destination) :-
    format('Finding the shortest path between ~w (source) and ~w (destination):\n', [Source, Destination]),
	djikstra(Source),                   
	reversePath([Destination|ReversePath], Weight)->        
	  reverse([Destination|ReversePath], Path),   
	  CumulativeWeight is round(Weight),
	  format('\tShortest path: P = ~w \n\tNo of edges in path: N = ~w\n\n',
	       [Path, CumulativeWeight]); 
	format('\tThere are no paths connecting nodes ~w and ~w!\n\n', [Source, Destination]).


% sample test cases to be executed:
?- shortest_path(1,12).
?- shortest_path(12,1).
?- shortest_path(11,99).
?- addFaultyNode(55).
?- removeFaultyNode(20).
?- removeFaultyNode(10).
?- shortest_path(11,99).
?- shortest_path(50,2).
?- addFaultyNode(65).
?- shortest_path(5,80).
?- removeFaultyNode(17).
?- shortest_path(4,50).
?- shortest_path(30,75).